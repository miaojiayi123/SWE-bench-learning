# SWE-agent对可配置软件系统的处理

## 可配置软件系统 Configurable Software System
**系统核心逻辑与实现细节分离： 运行时通过外部的配置来改变软件架构的功能、界面**
**维护着一个通用代码库，通过不同的配置来满足各种需求**

### 技术特点

#### 1.Separation
将用户界面和配置逻辑分离： **固定核心算法，可以配置输入、输出参数**

#### 2.Modularity
多个模块组成软件系统，模块特定分工

#### 3.Extensibility
插件、api添加功能

#### 4.Priority
系统默认配置-用户配置文件-命令行参数

### 技术实现

#### 1.配置文件 json，yaml，xml文件

#### 2.GUI（图形化界面），CLI（命令行）

#### 3.Dependency Injection（like Spring里的用法）

## 以Linux为例理解可配置软件系统

### 1.内核可配置
编辑 .config 文件来配置内核选项，禁用、启用特定功能来配置满足需求的内核

### 2.modularity
modprobe加载模块，动态加载

### 3.用户控制
命令行bash和图形界面（操作系统可视化界面、选项）

## 基于SWE-agent对处理可配置软件系统的可行性分析

### 1.支持自动化的内核配置
agent可以分析、理解配置选项，并根据prompt来优化内核配置

### 2.模块化设计
生成模块化代码，设计接口，并管理模块加载逻辑

### 3.GUI支持
ACI帮助LM理解可配置软件系统更改后的状态、管理历史记录，加强用户交互



# 加速SWE-agent对可配置软件系统大代码量情景下的缺陷定位、修复效率

**在调用deepseek api解决github上的测试问题时发现：对于一个代码量不大的项目来说，解决一个问题也需要几十个step多轮input与反馈。**
**如果把情景切换到代码量非常大的可配置软件系统时，解决问题的耗时、token消耗量会非常庞大**


## github issue --> 可配置系统软件 

1.在庞大代码量情形下，sweagent的上下文窗口长度的限制
2.问题的类别多样性：可配置软件出现的问题可能来自于用户日志、配置文件、runtime error等。
3.可配置软件系统作为集成化的软件系统，不同组件之间的依赖性非常强，出现一个问题可能牵扯到多个模块
4.对于大代码场景，遇到错误可能是系统产生了多个缺陷，场景更为复杂
5.效率需求

## possible solution

**窗口长度问题**
1.优化prompt，明确要求聚焦特定文件、函数
2.修改prompt template，轻量的提示让模型能更快的定位可能出现问题的文件、函数位置，分阶段地进行推理

**问题转化为结构化输入**
将日志、配置错误信息转化为结构化的问题便于agent理解：
1.设计解析日志的工具-->将日志展现的错误内容变成清晰简洁的输入
2.引入配置文件的校验模块

**提升效率**
对于频繁定位、访问到的代码段进行标记，将与之相关的依赖文件、关系进行缓存，减少重复的访问

**软件系统的依赖性分析**
1.预先用相关工具生成各个文件的依赖关系图，提供给swe-agent让llm先参考
2.定位依赖相关的缺陷：运行时日志，调试工具

**多缺陷处理**
分布式计算、提升硬件水平多个gpu并行处理


# 提高处理不同文件、函数间的缺陷传播关系的能力，提高缺陷定位和修复准确性

**上下文理解能力提升**
1.生成不同文件、函数与代码之间的静态依赖图作为额外参数提供给agent
2.代码库向量化，语义相似性进行定位
3.拆分任务，分阶段推理

**追踪缺陷关系**
1.动态分析日志、堆栈追踪callstack.txt
2.分析数据流，追踪相关变量参数在代码执行路径上的变化，识别缺陷是如何传播的

**定位缺陷**
1.文件级-->代码行级 prompt多阶段提示
2.标注不同代码区域的风险程度：高复杂度、高函数长度为高风险区域，应该优先分析

**修复准确性**
1.反馈测试失败的结果，迭代优化
2.提醒agent在修改代码时要考虑文件、函数的依赖性
3.验证解决了当前问题后是否因为依赖而引入了新的问题，及时回退采取其他策略 


# 不依赖于用户的结果反馈，根据测试结果定位和修复的完全自动化流程
**研究一个闭环 操作失败-->定位-->修复操作-->验证迭代**





# SWE-agent对可配置软件系统的应用







